#include "EncryptDecrypt.h"

void EncryptDecrypt::keyGen(int num, unsigned char* array) {
	int thisChar;
	std::random_device rd;  //Will be used to obtain a seed for the random number engine
	std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()

	//Use `distrib` to transform the random unsigned int generated by gen into an int in [1, 6]
	std::uniform_int_distribution<> distrib(33, 126); // uses ascii values

	for (int n = 0; n < num; n++)
	{
		thisChar = distrib(gen);
		if (thisChar == 48)
		{
			n--;
		}
		else
			*array++ = (char)thisChar;
	}
	//return 0;
}

void EncryptDecrypt::fullEncrypt(std::vector<std::string> vect, unsigned char* keyArray, unsigned char* ivArray) {
	for (int i = 0; i < vect.size(); i++)
	{
		bool validChar = true;
		unsigned char* plainText = (unsigned char*)vect[i].c_str();
		ciphertext_len = encrypt(plainText, strlen((char*)plainText), keyArray, ivArray, ciphertext);
	}

}
void EncryptDecrypt::fullDecrypt(std::vector<std::string> vect) {
	unsigned char locKey[32] = {};
	unsigned char locIv[16] = {};
	for (int i = 0; i < vect.size(); i++) {

		unsigned char* encryptedText = (unsigned char*)(vect[i].c_str());
		if (i == 0)
		{
			for (int j = 0; j < vect[i].size(); j++)
			{
				locKey[j] = vect[i][j];
			}
			//locKey = vectorString[i].c_str();
		}
		else if (i == 1)
		{
			for (int j = 0; j < vect[i].size(); j++)
			{
				locIv[j] = vect[i][j];
			}
			//locIv = encryptedText;
		}
		else
		{
			int encryptedText_len = vect[i].size();
			std::string locString;

			//decryptedtext_len = decrypt(encryptedText, encryptedText_len, keyArray, ivArray, dexryptedtext);
			decryptedtext_len = decrypt(encryptedText, encryptedText_len, locKey, locIv, dexryptedtext);

			dexryptedtext[decryptedtext_len] = '\0';
			locString = dexryptedtext[0];
			for (int ch = 1; ch < decryptedtext_len; ch++) {
				locString[ch] = dexryptedtext[ch];
			}

			decryptedVect.push_back(locString);
		}
	}
}

int EncryptDecrypt::encrypt(unsigned char* plaintext, int plaintext_len, unsigned char* key, unsigned char* iv, unsigned char* ciphertext) {
	EVP_CIPHER_CTX* ctx;
	int len;
	int ciphertext_len;

	/* create and initialise the context */
	if (!(ctx = EVP_CIPHER_CTX_new())) {
		errorHandling();
	}

	/* initialise the encryption operation.
	 * important!!! ensure you use a key and IV size appropriate fot your cipher
	 * in this example we are using 256 bit AES (i.e. a 256 bit key).
	 * the IV size for most modes is the same as the block sise
	 * for AES this is 128 bits */

	if (1 != EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, iv)) {
		errorHandling();
	}

	/* Provide the message to be encrypted and obtain the encrypted output.
	 * EVP_EncryptUpdate can be called multiple times if necessary */

	if (1 != EVP_EncryptUpdate(ctx, ciphertext, &len, plaintext, plaintext_len)) {
		errorHandling();
	}
	ciphertext_len = len;

	/* finalise the encryption. Further ciphertext bytes may be written at this stage. */

	if (1 != EVP_EncryptFinal_ex(ctx, ciphertext + len, &len)) {
		errorHandling();
	}
	ciphertext_len += len;

	/* Cleanup */
	EVP_CIPHER_CTX_free(ctx);

	return ciphertext_len;
}

int EncryptDecrypt::decrypt(unsigned char* ciphertext, int ciphertext_len, unsigned char* key, unsigned char* iv, unsigned char* plaintext)
{
	EVP_CIPHER_CTX* ctx;

	int len = 0;

	int plaintext_len = 0;

	/* Create and initialise the context */
	if (!(ctx = EVP_CIPHER_CTX_new())) {
		errorHandling();
	}

	/*
	 * Initialise the decryption operation. IMPORTANT - ensure you use a key
	 * and IV size appropriate for your cipher
	 * In this example we are using 256 bit AES (i.e. a 256 bit key). The
	 * IV size for *most* modes is the same as the block size. For AES this
	 * is 128 bits
	 */
	if (1 != EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, iv)) {
		errorHandling();
	}

	/*
	 * Provide the message to be decrypted, and obtain the plaintext output.
	 * EVP_DecryptUpdate can be called multiple times if necessary.
	 */
	if (1 != EVP_DecryptUpdate(ctx, plaintext, &len, ciphertext, ciphertext_len)) {
		errorHandling();
	}
	plaintext_len = len;

	/*
	 * Finalise the decryption. Further plaintext bytes may be written at
	 * this stage.
	 */
	if (1 != EVP_DecryptFinal_ex(ctx, plaintext + len, &len)) {
		errorHandling();
	}
	plaintext_len += len;

	/* Clean up */
	EVP_CIPHER_CTX_free(ctx);

	return plaintext_len;

}

void EncryptDecrypt::errorHandling(void)
{
	ERR_print_errors_fp(stderr);
	abort();
}

void EncryptDecrypt::initEncryption(std::string fileName) {
	std::string localString = {};
	inFile.open(fileName);
	while (getline(inFile, fileLine)) {
		localString = fileLine;
		fileVector.push_back(localString);
	}
	inFile.close();

	keyGen(32, keyArray);
	writeEncryptedFile("enc_" + fileName, keyArray, 32);
	keyGen(16, ivArray);
	writeEncryptedFile("enc_" + fileName, keyArray, 16);

	fullEncrypt(fileVector, keyArray, ivArray);
	writeEncryptedFile("enc_" + fileName, ciphertext, ciphertext_len);
}

void EncryptDecrypt::writeEncryptedFile(std::string fileName, unsigned char* thisArr, int textLength) {
	std::string locString = "";
	locString = thisArr[0];
	for (int j = 1; j < textLength; j++)
	{
		locString += thisArr[j];
	}
	locString += "\0";
	std::vector<base64::byte> encodeData(begin(locString), end(locString));
	auto encodedString = base64::encode(encodeData);
	outFile.open(fileName, std::ios::app);
	outFile << encodedString;
	outFile << std::endl;
	outFile.close();
}
